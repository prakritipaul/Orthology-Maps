---
title: "notoXnoto_pipeline"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(Seurat)
library(tidyverse)
library(stringr)
library(ggplot2)
library(Matrix)
library(ggcorrplot)
library(psych)
```

############ STEP 1 #############
# Make the appropriate test variables.
# REAL: "ortho_mapping"
```{r include=TRUE}
ortho_dict <- read.table("/home/pprakriti/Desktop/export_qualified_one2one_many_notoxnoto_dict.csv",
                         sep = ",",
                         header = FALSE,
                         stringsAsFactors = FALSE)
colnames(ortho_dict) <- c("khid", "zeb_gene")

ortho_mapping <- ortho_dict %>%
   separate_rows(zeb_gene, sep = " ")
```

# There was an error in 8hpf and 18hpf noto_matrices.
```{r include=TRUE}
zeb_8hpf_noto_mat <- zeb_8hpf_df[, zeb_8hpf_noto_cells]
zeb_18hpf_noto_mat <- zeb_18hpf_df[, zeb_18hpf_noto_cells]
```

##########   RESOLVED: WE NEED TO UNDERSTAND HOW TO DEAL WITH ZEB DUPLICATES  #########

# Ortho khids and zeb_genes.
```{r include=TRUE}
# 4363 (correct, as expected).
ortho_khids <- unique(ortho_mapping$khid)

# 8548 -> 6490 => There are many-1 orthologs (ciona -> zeb).
ortho_zeb_genes <- ortho_mapping$zeb_gene
```

```{r include=TRUE}
# This is a dataframe with zeb_genes that have 1-1 and 1-many orthologs. (U)
# 5490 
unique_zeb_gene_df <- ortho_mapping %>% group_by(zeb_gene) %>% summarise(num = n()) %>%
  filter(num == 1)
# 5490
unique_ortho_zeb_genes <- unique_zeb_gene_df$zeb_gene

# These are the khids that correspond to zeb_genes in U. 
# There will be repeats because there are 1 KHID -> multiple zeb_genes cases.   
# 5490
corr_khid_U <- ortho_mapping %>% filter(zeb_gene %in% unique_ortho_zeb_genes)
# 3766
corr_khids <- unique(corr_khid_U$khid)
```

############ MAKE AND MUNGE iniG_noto_mat/zeb_8hpf_noto_mat -> subset_iniG/subset_8hpf ############

# Helper Function.
```{r include=TRUE}
modify_mat <- function(mat, subset_genes, col_rowname) {
  # Munges Matrix of batch-corrected values from noto_mats (mat) into a dataframe with 
  # rownames of khids/zeb_genes (mod_mat). Its column name is col_rowname = khid/zeb_gene.
  # subset_genes = ortho_khids/ortho_zeb_genes.
  mod_mat <- as.data.frame(mat[subset_genes, ])
  mod_mat[[col_rowname]] <- rownames(mod_mat)
  return(mod_mat)
}
```

# Do for Ciona.
```{r include=TRUE}
# REAL: subset_iniG <- modify_mat(iniG_noto_mat, ortho_khids, "khid")
subset_iniG <- modify_mat(iniG_noto_mat, corr_khids, "khid")
subset_midG <- modify_mat(midG_noto_mat, corr_khids, "khid")
subset_earN <- modify_mat(earN_noto_mat, corr_khids, "khid")
subset_latN <- modify_mat(latN_noto_mat, corr_khids, "khid")
subset_iniT <- modify_mat(iniT_noto_mat, corr_khids, "khid")
subset_earT <- modify_mat(earT_noto_mat, corr_khids, "khid")
subset_midT <- modify_mat(midT_noto_mat, corr_khids, "khid")
subset_LTB1 <- modify_mat(LTB1_noto_mat, corr_khids, "khid")
subset_LTB2 <- modify_mat(LTB2_noto_mat, corr_khids, "khid")
subset_larva <- modify_mat(larva_noto_mat, corr_khids, "khid")
```

# Do for Zeb.
```{r include=TRUE}
# REAL: subset_10hpf <- modify_mat(zeb_10hpf_noto_mat, ortho_zeb_genes, "zeb_gene")
subset_8hpf <- modify_mat(zeb_8hpf_noto_mat, unique_ortho_zeb_genes, "zeb_gene")
subset_10hpf <- modify_mat(zeb_10hpf_noto_mat, unique_ortho_zeb_genes, "zeb_gene")
subset_14hpf <- modify_mat(zeb_14hpf_noto_mat, unique_ortho_zeb_genes, "zeb_gene")
subset_18hpf <- modify_mat(zeb_18hpf_noto_mat, unique_ortho_zeb_genes, "zeb_gene")
subset_24hpf <- modify_mat(zeb_24hpf_noto_mat, unique_ortho_zeb_genes, "zeb_gene")
```


############# COLLAPSE ZEB MATS subset_8hpf -> subset_8hpf_collapse (no khid col, only expression matrix) #############
 
# Helper Function.  
```{r include=TRUE}
collapse_zeb_mat <- function(zeb_mat, ortho_mapping) {
  # zeb_mat (n_zeb_genes x cells + zeb_gene) + ortho_mapping -> 
  # zeb_collapse (n_khids, cells). "Collapse" refers to summing zeb_orthos.
  zeb_collapse <- zeb_mat %>% left_join(ortho_mapping)
  zeb_collapse <- zeb_collapse %>% group_by(khid) %>%
  summarize((across(starts_with("DEW"), sum))) %>%
  select(-khid)
return(zeb_collapse)
}
```

```{r include=TRUE}
# Collapses to 3766- perfect! 
subset_8hpf_collapse <- collapse_zeb_mat(subset_8hpf, ortho_mapping)
subset_10hpf_collapse <- collapse_zeb_mat(subset_10hpf, ortho_mapping)
subset_14hpf_collapse <- collapse_zeb_mat(subset_14hpf, ortho_mapping)
subset_18hpf_collapse <- collapse_zeb_mat(subset_18hpf, ortho_mapping)
subset_24hpf_collapse <- collapse_zeb_mat(subset_24hpf, ortho_mapping)
```

############ GET RID OF KHID COLUMNS (no longer has khid col) ##############

```{r include=TRUE}
remove_khid_column <- function(ciona_matrix) {
  clean_ciona_matrix <- ciona_matrix %>% select(-khid)
  return(clean_ciona_matrix)
}
```

```{r include=TRUE}
subset_iniG_clean <- remove_khid_column(subset_iniG)
subset_midG_clean <- remove_khid_column(subset_midG)
subset_earN_clean <- remove_khid_column(subset_earN)
subset_latN_clean <- remove_khid_column(subset_latN)
subset_iniT_clean <- remove_khid_column(subset_iniT)
subset_earT_clean <- remove_khid_column(subset_earT)
subset_midT_clean <- remove_khid_column(subset_midT)
subset_LTB1_clean <- remove_khid_column(subset_LTB1)
subset_LTB2_clean <- remove_khid_column(subset_LTB2)
subset_larva_clean <- remove_khid_column(subset_larva)
```

############# MAKE LISTS (genes x cells) ciona/zeb_list #############
```{r include=TRUE}
# Note: Rownames have khids. 
ciona_list = list(iniG = subset_iniG_clean,
                  midG = subset_midG_clean,
                  earN = subset_earN_clean,
                  latN = subset_latN_clean,
                  iniT = subset_iniT_clean,
                  earT = subset_earT_clean,
                  midT = subset_midT_clean,
                  LTB1 = subset_LTB1_clean,
                  LTB2 = subset_LTB2_clean,
                  larva = subset_larva_clean)
```

```{r include=TRUE}
# Note: Rownames do not have names (makes sense).
zeb_list = list(zeb_8hpf = subset_8hpf_collapse,
                zeb_10hpf = subset_10hpf_collapse,
                zeb_14hpf = subset_14hpf_collapse,
                zeb_18hpf = subset_18hpf_collapse,
                zeb_24hpf = subset_24hpf_collapse)
```


################### REMOVE GENES THAT ARE NOT EXPRESSED IN ANY CELLS ###################

### Check if there are any 0's ###
```{r include=TRUE}
all_num <- function(your_row, your_num) {
  # Do you see your_num in all entries of your_row?
  # Function can be used to check this in a column- just change MARGIN.
  # Retursn logical.
  ifelse (all(your_row == your_num), TRUE, FALSE)
}

any_num <- function(your_row, your_num) {
  # As above. 
  ifelse (any(your_row == your_num), TRUE, FALSE)
}
```

### Check if there are any 0's ###
```{r include=TRUE}
# Input needs to be a dataframe, not a row of the dataframe! 
# if col = 0 (MARGIN=2), cell isn't expressing anything; if row = 0, gene is not expressed in any cells (MARGIN=1) 
all_num_logical <- apply(zeb_list$zeb_8hpf, MARGIN=1, FUN=all_num, your_num=0)
all_num_sum <- sum(all_num_logical)
all_num_sum

# Where are these rows? Eventually we want to take the UNION of these and eliminate them from the analyses- just like Tosches! 
where_0 <- as.numeric(which(all_num_logical))
where_0

```

# Helper Function.
```{r include=TRUE}
get_0_indices <- function(your_dataframe) {
  all_num_logical <- apply(your_dataframe, MARGIN=1, FUN=all_num, your_num=0)
  where_0 <- as.numeric(which(all_num_logical))
  return(where_0)
}
```

# Get indices of all genes that are not expressed in any cells. 
```{r include=TRUE}
# Get indices in Ciona. 59
genes_0_ciona <- unique(unlist(map(ciona_list, get_0_indices)))
# Get indices in Zeb. 842
genes_0_zeb <- unique(unlist(map(zeb_list, get_0_indices)))
# Take the union of these. Make sure to unique them! 890
all_genes_0 <- unique(union(genes_0_ciona, genes_0_zeb))
```   

# Remove those genes! 
```{r include=TRUE}
test_remove <- c(1, 2, 3)
test_df_remove <- test_df[-test_remove, ]
test_df_remove
```

############# GSM THEM ciona_list -> ciona_list_gsm ############ 

# Helper Function. 
```{r include=TRUE}
make_gsm <- function(expression_matrix) {
  # Makes Gene Specificity Matrix, Tosches 2018.
  #
  # Args: 
  #   expression_matrix: genes x cells. 
  #   e.g. test_10hpf_collapse (nrow=n_khids x Zeb Noto Cells)
  #
  # Returns:
  #   gsm: Expression of each gene is normalized to its mean expression in all cells.
  gsm <- expression_matrix
  gsm <- gsm %>% mutate(gene_avexp = rowMeans(.)) %>% 
    mutate_at(vars(-gene_avexp), ~.x/gene_avexp) %>% 
    select(-gene_avexp)
  
  return(gsm)
}
```

# Now you have the gsm'ed expression value matrices.
```{r include=TRUE}
ciona_list_gsm <- map(ciona_list, make_gsm)
```

```{r include=TRUE}
zeb_list_gsm <- map(zeb_list, make_gsm)
```

# TRY THIS- CHANGE ALL NANS TO 0S AND SEE WHAT HAPPENS.
```{r include=TRUE}
new_8hpf <- zeb_list_gsm$zeb_8hpf
new_8hpf[is.na(new_8hpf)] <- 0

new_10hpf <- zeb_list_gsm$zeb_10hpf
new_10hpf[is.na(new_10hpf)] <- 0

new_14hpf <- zeb_list_gsm$zeb_14hpf
new_14hpf[is.na(new_14hpf)] <- 0

new_18hpf <- zeb_list_gsm$zeb_18hpf
new_18hpf[is.na(new_18hpf)] <- 0

new_24hpf <- zeb_list_gsm$zeb_24hpf
new_24hpf[is.na(new_24hpf)] <- 0
```

# New zeb gsm list 
```{r include=TRUE}
new_zeb_gsm <- list(new_8hpf = new_8hpf,
                    new_10hpf = new_10hpf,
                    new_14hpf = new_14hpf,
                    new_18hpf = new_18hpf,
                    new_24hpf = new_24hpf)
```

############ START TROUBLESHOOTING: ANY NANS? ################

# Get individual gsms. 
```{r include=TRUE}
test_ciona_gsm <- ciona_list$iniG
```

```{r include=TRUE}
test_zeb_gsm <- zeb_list_gsm$zeb_8hpf
```

# Set a subset 
```{r include=TRUE}
your_subset <- test_zeb_gsm
```

# (1) Check if any NaN- Yes for Zeb GSMs. 
```{r include=TRUE}
sum(is.na(your_subset))
```

# Are there rows with mean of 0?
```{r include=TRUE}

test_8hpf <- subset_8hpf_collapse %>% mutate(my_mean = rowMeans(.)) %>%
  mutate(khids = corr_khids) %>%
  filter(my_mean == 0) %>%
  select(my_mean, khids)
```

# Example of khid with mean 0 
```{r include=TRUE}
test_khid <- "KH2012:KH.C3.815"
# dse dsela
test_ortho_strings <- ortho_dict

test_ortho_strings
```

############ END TROUBLESHOOTING: ANY NANS? ################

# Cross test_ciona_list_gsm and test_zeb_list_gsm to make pairs of gsm'ed noto matrices (c x z) = test_cross_gsm. 
```{r include=TRUE}
# Here I want to get pairwise key names. # zeb_list_gsm
cross_gsm <- cross2(ciona_list_gsm, new_zeb_gsm)
```

# Give informative key names.
# CODE REC: These are a lot of lines of code to achieve this...

# Helper Function.
```{r include=TRUE}
give_names <- function(your_list) {
  name_1 <- your_list[[1]]
  name_2 <- your_list[[2]]
  name_flag <- paste0("gsm_", name_1, "/", name_2)
  return(name_flag)
}
```

# Get the names - CORRECT 
```{r include=TRUE}
cross_gsm_names <- cross2(names(ciona_list_gsm), names(zeb_list_gsm))
cross_gsm_names <- cross_gsm_names %>% map(give_names)

names(cross_gsm) <- cross_gsm_names
```

# I want to do a function on each of these pairs- present in [[1]] and [[2]].
```{r include=TRUE}
do_correlation <- function(pairwise_gsm_mats) {
  cat("Starting \n\n")
  ciona_gsm <- pairwise_gsm_mats[[1]]
  zeb_gsm <- pairwise_gsm_mats[[2]]
  corr_output <- corr.test(x= ciona_gsm,
                           y = zeb_gsm,
                           method = "spearman",
                           adjust = "fdr")
  return(corr_output)
}
```

# Apply cor to all the pairs and get results = test_gsm_corrs. 
```{r include=TRUE}
# List of length 4. 
gsm_corrs <- map(cross_gsm, do_correlation)
names(gsm_corrs) <- cross_gsm_names
```

# Get significant correlations. 
```{r include=TRUE}
get_sig_corrs <- function(corr_output) {
  # corr_output e.g. gsm_test_iniG/test_10hpf (item in test_gsm_corrs list)
  corr_r <- corr_output$r
  corr_p <- corr_output$p
  
  which_p <- which(corr_p < 0.05)
  sig_corr <- corr_r[which_p]
  return(sig_corr)
}
```

# Do for all and give informative names.
```{r include=TRUE}
sig_corrs <- map(gsm_corrs, get_sig_corrs)
sig_corrs_names <- str_remove(names(gsm_corrs), "gsm_")
names(sig_corrs) <- sig_corrs_names
```

# Now take the median!
```{r include=TRUE}
medians <- map_dbl(sig_corrs, median)
medians
```
# Make a matrix -> heatmap
```{r include=TRUE}
heatmap_mat <- as.data.frame(matrix(medians, nrow=length(ciona_list), ncol=length(zeb_list)))

rownames(heatmap_mat) <- names(ciona_list)
colnames(heatmap_mat) <- names(zeb_list)
```

# Consider what I might do if there are NAs... Just for testing
# ```{r include=TRUE}
# test_NA_indices <- is.na(test_heatmap_mat)
# test_heatmap_mat[test_NA_indices] <- c(0.4, 0.1, 0.8, 0.2)
# ```

```{r include=TRUE}
ggcorrplot(heatmap_mat)
```




############### TESTS #################

```{r include=TRUE}
test_df <- data.frame(a = c(0, 0, 0, 0, 0, 0, 0), b = c(1, 0, 1, 4, 1, 2, 3), d = c(1, 0, 1, 3, 4, 7, 2))
test_df

test_df_2 <- data.frame(a = c(1, 2, 5, 6), b = c(4, 5, 3, 4), d = c(2, 6, 7, 3))
test_df_2

test_df_3 <- data.frame(a = c(1, 2, 3, 4), b = c(5, 6, 7, 8), c = c(9, 10, 11, 12))
test_df_3

test_df_4 <- data.frame(a = c(1, 5, 6, 4), b = c(10, 1, 3, 8), c = c(9, 1, 2, 3))
test_df_4

test_df_5 <- data.frame(a = c(1, 5, 10, 5), b = c(10, 1, 2, 8), c = c(9, 1, 2, 4))
test_df_5
```
# Remove rows given indices. 
```{r include=TRUE}
test_remove <- c(1, 2, 3)
test_df_remove <- test_df[-test_remove, ]
test_df_remove
```

# Check if there are any 0's
```{r include=TRUE}
all_num <- function(your_row, your_num) {
  # Either find all or any of a number in a row. Returns logical.
  ifelse (all(your_row == your_num), TRUE, FALSE)
}

any_num <- function(your_row, your_num) {
  # Either find all or any of a number in a row. Returns logical.
  ifelse (any(your_row == your_num), TRUE, FALSE)
}
```

```{r include=TRUE}
test_test_df <- test_df
any_num_logical <- apply(test_test_df, MARGIN=2, FUN=any_num, your_num=0)
any_num_sum <- sum(any_num_logical)
any_num_sum

all_num_logical <- apply(test_test_df, MARGIN=2, FUN=all_num, your_num=0)
all_num_sum <- sum(all_num_logical)
all_num_sum

```


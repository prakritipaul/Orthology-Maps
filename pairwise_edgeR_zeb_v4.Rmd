---
title: "parallel"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Uses slim_env_v4.RData.

# zeb_ans_list_(0) were generated here.
# Correspond to v4_pairwise_zeb_(0).RData.

# Generates pairwise DEGs for 12 Zeb CTs.

# Messy protoypes for generating unique pairwise DEGs for all Zeb CTs.
# Intractable in Vera! 
# Note: zeb_counts = 30677 x 34750 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(Seurat)
library(dplyr)
library(ggplot2)
library(purrr)
library(Hmisc)
library(pvclust)
library(edgeR)
```

*** Zeb Count Data ***

```{r include=TRUE}
# How to get raw counts (I turned this into a dataframe at some point... idk)
zeb_counts <- zeb_integrated_50[["RNA"]]@counts
```

*** COMPLETED RUNS ****

"""
Variables for Pairwise, Zeb 12 CT (Done)
"""

```{r include=TRUE}
zeb_pec_fin_bud_mat <- zeb_counts[, pec_fin_bud]
zeb_panc_prim_endo_mat <- zeb_counts[, panc_prim_endo]
zeb_noto_mat <- zeb_counts[, noto]
zeb_muscles_mat <- zeb_counts[, muscles]
zeb_meso_mat <- zeb_counts[, meso]
zeb_leuko_mat <- zeb_counts[, leuko]
zeb_diff_neus_mat <- zeb_counts[, diff_neus]
zeb_epi_1_mat <- zeb_counts[, epi_1]
zeb_epi_2_mat <- zeb_counts[, epi_2]
zeb_heart_51_56_mat <- zeb_counts[, heart_51_56]
zeb_heart_52_mat <- zeb_counts[, heart_52]
zeb_tail_spinal_cord_mat <- zeb_counts[, tail_spinal_cord]

zeb_mats <- list(noto = zeb_noto_mat,
                 muscles = zeb_muscles_mat,
                 pec_fin_bud = zeb_pec_fin_bud_mat,
                 panc_prim_endo = zeb_panc_prim_endo_mat,
                 meso = zeb_meso_mat,
                 leuko = zeb_leuko_mat,
                 diff_neus = zeb_diff_neus_mat,
                 epi_1 = zeb_epi_1_mat,
                 epi_2 = zeb_epi_2_mat,
                 heart_51_56 = zeb_heart_51_56_mat,
                 heart_52 = zeb_heart_52_mat,
                 tail_spinal_cord = zeb_tail_spinal_cord_mat)

```

### DO NOT RUN AGAIN!!! ###
```{r include=TRUE}
# Gets pairwise DEGs for 12 CTs above.
zeb_ans_list_0 <- master_edgeR_pipeline(zeb_mats, 0.05, 0)
```

#############################

### TRY ALL PAIRWISE ###

# Let's make a zeb mat list with mats for all CTs
```{r include=TRUE}
all_zeb_mats <- list()

for (i in 1:length(zeb_cell_type_list)) {
  CT_name <- all_zeb_CT_names[i]
  cat("CT = ", CT_name, "\n\n")
  CT_cells <- zeb_cell_type_list[[i]]
  
  CT_df <- zeb_counts[, CT_cells]
  all_zeb_mats[[CT_name]] <- CT_df
}
```
### TRY THIS!!! ###
```{r include=TRUE}
all_zeb_ans_list <- master_edgeR_pipeline(all_zeb_mats, 0.05, 1)
```

"""
Start Helper Functions 
"""
```{r include=TRUE}
edgeR_pipeline <- function(pair_mat, rep_1, rep_2){
  # Given a matrix with gene expression values for 2 CTs, get DEGs.
  # Args:
  #       pair_mat: As above.
  #       e.g. psc_wt_mat (a_b_mat)
  #
  #       rep_1; rep_2: Number of cells for each CT. 
  #       e.g. ncol(a_mat); ncol(b_mat)
  #
  # Returns:
  #       edgeR_res: Dataframe with columns logFC, logCPM, F, PValue.
  #       Note: Want edgeR output logFC < 0 to get genes that are more 
  #             highly expressed in rep_1 compared to rep_2.  

  group = factor(c(rep(1, rep_1), rep(2, rep_2)))
  y = DGEList(counts=pair_mat, group=group)
  y = calcNormFactors(y)
  design = model.matrix(~group)
  y = estimateDisp(y, design)
  
  fit <- glmQLFit(y,design)
  # Find DEGs between two CTs.
  qlf <- glmQLFTest(fit,coef=2)
  # Save results as a Dataframe.
  edgeR_res <- qlf$table
  return(edgeR_res)
}
```

```{r include=TRUE}
sort_edgeR_res <- function(edgeR_res, adj_PValue_thresh) {
  # Given the output of edgeR_pipeline, sort DEGs by logFC and adjusted p-value.
  # 
  # Args:
  #     edgeR_res: Dataframe returned by edgeR_pipeline.
  #     adj_PValue_thresh: Threshold.
  #
  # Returns:
  #     sorted_edgeR_res: Self-explanatory. (Dataframe)
  
  sorted_edgeR_res <- edgeR_res
  sorted_edgeR_res <- sorted_edgeR_res[order(sorted_edgeR_res$logFC), ]
  # Make adj_PValue column. 
  adj_pValues <- p.adjust(sorted_edgeR_res$PValue, method="fdr", nrow(sorted_edgeR_res))
  sorted_edgeR_res$adj_PValue = adj_pValues
  # Sort. 
  sorted_edgeR_res <- sorted_edgeR_res[sorted_edgeR_res$adj_PValue < adj_PValue_thresh, ]
  # Filter. 

  return(sorted_edgeR_res)
}
```

```{r include=TRUE}
filter_edgeR_res <- function(sorted_edgeR_res, logFC_thresh) {
  # Given a sorted edgeR output (Dataframe), filter DEGs given a logFC threshold.
  #
  # Args:
  #     sorted_edgeR_res, logFC_threshold: Self-explanatory.
  #
  # Returns:
  #     filtered_edgeR_res: Self-explanatory. (Dataframe)
  
  filtered_edgeR_res <- sorted_edgeR_res
  filtered_edgeR_res <- filter(filtered_edgeR_res, logFC < logFC_thresh)
  rownames(filtered_edgeR_res) <- rownames(sorted_edgeR_res)[1:nrow(filtered_edgeR_res)]
  
  return(filtered_edgeR_res)
} 
```


*** For Pairwise DEG Calculations ***

```{r include=TRUE}
master_edgeR_pipeline <- function(mats, adj_PValue_thresh, logFC_thresh) {
  # Pipeline description below.
  # 
  # Args:
  #     mats: List of raw matrices of various CTs.
  #     e.g. ciona_mats <- list(noto = ciona_noto_mat)
  #          where ciona_noto_mat <- ciona_counts[, ciona_larva_noto]
  #
  # Routine:
  #     1. Perform pairwise edgeR among all CTs.
  #     2. Sort and filter edgeR_res Dataframe -> filtered_edgeR_res.
  #     3. Save these in edgeR_res_list.
  #     4. Add DEGs to edgeR_degs.
  #     5. Get the unique DEGs. Present in unique_edgeR_degs.
  #
  # Returns:
  #     ans_list: list containing edgeR_res_list and unique_edgeR_degs.
  names <- names(mats)
  
  edgeR_res_list <- list()
  # 8445
  edgeR_degs <- c()
    
  for (i in 1:length(mats)) {
    for (j in 1:length(mats)) {
      if (i != j) {
        name_1 <- names[[i]]
        name_2 <- names[[j]]
        cat("i = ", i, "CT1 = ", name_1, "j = ", j, "CT2 = ", name_2, "\n\n")
        
        pair_1 <- mats[[i]]
        pair_2 <- mats[[j]] 
        pair_mat <- cbind(pair_1, pair_2)
        
        # Do edgeR 
        edgeR_res <- edgeR_pipeline(pair_mat, ncol(pair_1), ncol(pair_2))
        # Sort
        sorted_edgeR_res <- sort_edgeR_res(edgeR_res, adj_PValue_thresh)
        # Filter
        filtered_edgeR_res <- filter_edgeR_res(sorted_edgeR_res, logFC_thresh)
        # 
        pair_mat_name <- paste0(name_1, "_", name_2)
        edgeR_res_list[[pair_mat_name]] <- filtered_edgeR_res
        # Get DEGs
        DEGs <- rownames(filtered_edgeR_res)
        edgeR_degs <- c(edgeR_degs, DEGs)
      }
    }
  }
  
  unique_edgeR_degs<- unique(edgeR_degs)
  ans_list <- list("edgeR_res_list" = edgeR_res_list,
                   "unique_edgeR_degs" = unique_edgeR_degs)
  return(ans_list)
  }
```

"""
End Helper Functions
"""



















#####  TESTING TESTING #####

<!-- ```{r include=TRUE} -->
<!-- write.csv(zeb_counts, "/home/pprakriti/Desktop/zeb_counts.csv") -->
<!-- ``` -->

# Let's first filter the raw matrices, and then run edgeR on them. 
```{r include=TRUE}
test.mat <- as.data.frame(matrix(c(3, 0, 1, 0, 
                                   4, 1, 2, 0, 
                                   2, 0, 1, 0,
                                   0, 1, 1, 2),
                   nrow=4,
                   ncol=4,
                   byrow = TRUE))

colnames(test.mat) <- c("cell_1", "cell_2", "cell_3", "cell_4")
rownames(test.mat) <- c("gene_1", "gene_2", "gene_3", "gene_4")
```

```{r include=TRUE}
test.zeb.counts <- zeb_counts[1:30, 1:10]
```

########################################

# (1a) Turn all non-0 integers to 1
```{r include=TRUE}
test.mat.2 <- test.mat
test.mat.2[test.mat.2 != 0] <- 1
```

# (1b)
```{r include=TRUE}
test.zeb.counts.2 <- test.zeb.counts
test.zeb.counts.2[test.zeb.counts.2 != 0] <- 1
```

# (Real)
```{r include=TRUE}
zeb.counts.2 <- zeb_counts
zeb.counts.2[zeb.counts.2 != 0] <- 1
```


# (2a) Are there any non-1 elements?
```{r include=TRUE}
any(test.mat > 1)
any(test.mat.2 > 1)
```

# (2b) 
```{r include=TRUE}
any(test.zeb.counts > 1)
any(test.zeb.counts.2 > 1)
```

# (Real) 
```{r include=TRUE}
# any(zeb_counts > 1)
any(zeb.counts.2 > 1)
```

# (3a) Get indices of unfiltered genes and cells.
```{r include=TRUE}
test.min.cells <- 3
test.min.genes <- 2

test.gene.indices.mat <- which(rowSums(test.mat.2) >= test.min.cells)
test.cells.indices.mat <- which(colSums(test.mat.2) >= test.min.genes)
```

# (3b)
```{r include=TRUE}
test.min.cells <- 3
test.min.genes <- 2

test.genes.indices <- which(rowSums(test.zeb.counts.2) >= test.min.cells)
test.cells.indices <- which(colSums(test.zeb.counts.2) >= test.min.genes)
```

# (Real)
```{r include=TRUE}
min.cells <- 300
genes.indices <- which(rowSums(zeb.counts.2) >= min.cells)
```

```{r include=TRUE}
min.genes <- 2000
cells.indices <- which(colSums(zeb.counts.2) >= min.genes)
```

# No point continuing because there are just too many cells and genes for this to be tractable. 

# (4a) Get their names. 
```{r include=TRUE}
test.genes.mat <- rownames(test.mat.2)[test.gene.indices.mat]
test.cells.mat <- rownames(test.mat.2)[test.cells.indices.mat]

```

# (4b)
```{r include=TRUE}
test.genes <- rownames(test.zeb.counts.2)[test.genes.indices]
test.cells <- rownames(test.zeb.counts.2)[test.cells.indices]

```

<!-- # We don't want this.  -->
<!-- ```{r include=TRUE} -->
<!-- test.filtered.mat.2 <- test.mat.2[rownames(test.mat.2) %in% test.genes.mat, ] -->
<!-- test.filtered.mat.2 <- test.filtered.mat.2 %>% select(all_of(test.cells.indices.mat)) -->
<!-- ``` -->

# (5a) Filter original raw matrix based on these names/indices.
```{r include=TRUE}
test.filtered.mat <- test.mat[rownames(test.mat) %in% test.genes.mat, ]
test.filtered.mat <- test.filtered.mat %>% select(all_of(test.cells.indices.mat))
```

# (5b)
```{r include=TRUE}
test.filtered <- test.zeb.counts[rownames(test.zeb.counts) %in% test.genes, ]
test.filtered <- test.filtered %>% select(all_of(test.cells.indices))
```


# All genes test on Noto. Intractable on Vera.  
```{r include=TRUE}
test_noto <- zeb_counts[, noto]
test_not_noto <- zeb_counts[, !(colnames(zeb_counts) %in% noto)]
test_pair <- cbind(test_noto, test_not_noto)
# test_edgeR <- edgeR_pipeline(test_pair, ncol(test_noto), ncol(test_not_noto)
```

```{r include=TRUE}
write.csv(test_pair, "/home/pprakriti/Desktop/test_pair.csv")
```

```{r include=TRUE}
test_load <- read.table("/home/pprakriti/Desktop/test_pair.csv",
                        header = TRUE,
                        sep = ",",
                        row.names = 1)
```

# Small 
```{r include=TRUE}
small_test_pair <- test_pair[1:10000, 1:500]

write.csv(small_test_pair, "/home/pprakriti/Desktop/small_test_pair.csv")
```

```{r include=TRUE}
small_test_load <- read.table("/home/pprakriti/Desktop/small_test_pair.csv",
                        header = TRUE,
                        sep = ",",
                        row.names = 1)
```

```{r include=TRUE}
small_test_edgeR <- edgeR_pipeline(small_test_load, 250, 250)
```

############################################################
DUMPS

# Tried subsetting genes to just 1-1 orthos to see if it would run faster... no it didn't
# Plus it makes no sense. 
```{r include=TRUE}
one2one_zeb_counts <- as.data.frame(zeb_counts)
one2one_zeb_counts <- subset(one2one_zeb_counts, rownames(one2one_zeb_counts) %in% one2one_zeb_genes)

# one2one_zeb_counts$genes <- rownames(zeb_counts)
# one2one_zeb_counts %>% filter(genes %in% one2one_zeb_genes)
```


